---
layout: post
title: "WiFi enabled 7-segment JSON display"
date: 2018-05-21
categories:
  - Side-Projects
description: 
image: https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/IPPIOT_title.png
image-sm: https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/IPPIOT_title.png
---
I wanted to build an Internet of Things (IoT) device while also improving my skills in microcontrollers and in design.  The main goal was to make a simple device while also being both a useful excercise and robust/usable product. With this in mind, I designed and built widget which connects to the internet, polls a website for a JSON, extracts a specific number (for example the experimental shot number or air quality index) and displays it via an SPI-connected 8-digit 7-segment display. The finished product feels like the 21st century equivalent of a bed-side clock, but with much more versatility. This project really highlights the revolution in design allowing for a hobbyist to make complicated products while maintaining both a low development cost and a fast design process.    

Doing this required three different segments, designing an integration between the two main electronic components, a housing to mate these components, and code to drive the whole device.  Each piece provided some unique difficulty,

This required solutions for the following challenges:

<ul>
  <li>Proper design tolerancing of parts for print variability and poor electronics workmanship</li>
  <li>PCB design which matches physical and electrical requirements at 3.3 and 5V</li>
  <li>Using the C-based workflow to properly utilize the ESP-01 </li>
</ul>

As it might seem that each problem is distinct and that these challenges are given cronologically, that was not the case. Each are significantly interrelated, where physical constraints impacted the electronic design which in turn changed the way in which the microcontroller would be programmed. The PCB design and case CAD design did progress before the actual coding, but after the general characteristics of the microcontroller control were defined. Overall, this project was enjoyable in the necessary problem solving, but also allowed me to take pride in the quality and finish of the end product. 

<h3> 3D printing of a compact housing</h3>

  <figure>
    <img src="https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/CAD_IPPIOT.jpg" alt="CAD of housing"/>
    <figcaption>The case was designed to be aestheically pleasing while also easy to be 3d printed. The two parts separate the 7 segment display from the control ESP8266 and interface board. Tolerancing was important for the screen, the micro USB interface, and mating surfaces between the 3d printed parts. </figcaption>
  </figure>


<h3> Designing and building an interfacing cicruit board</h3>



  <figure>
    <img src="https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/ESP8266_schematic.png" alt="Electronic schematic of mating board"/>
    <figcaption>The 7-segment display runs at 5V, with the ESP8266 at 3.3V. The interface board supplies the necessary voltages for these components (with a regulator), and the necessary level shifting for communcation (based off a similar Adafruit dev board). Micro USB was chosen due to the ubiquity of power sources (especially as things switch to USB-C).</figcaption>
  </figure>

  <figure>
    <img src="https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/g5517.png" alt="PCB CAD for mating board"/>
    <figcaption> Odd trace routing was necessary due to available IO pins on ESP-01. The 5 output pins are designed to match a specific 8 digit 7 segment display with a MAX7221. The hole beside the USB connector allows for a necessary M3 screw needed for mating the 3d printed case (showing how PCB and Case design occurred concurrently). Additional mounting screws and solder holes of Molex connector minimize strain on microUSB solder joint. </figcaption>
  </figure>

  <figure>
    <img src="https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/IMG_20180528_144417327.jpg" alt="PCB board progression"/>
    <figcaption>The design utilizes surface mount components to minimize the interface board size. Rather than using a reflow oven, components soldered by hand. This required a larger layout to reduce soldering difficulty.  The boards cheaply manufactured by Seeed Studio, by their printing standards..</figcaption>
  </figure>

<h3> Writing the microcontroller C code</h3>

When I first conceptualized the necessary components for this project, the implementation of arduino-based ESP8266 control was still in its infancy.  Initally, I wanted the wifi to connect to the rather ubiquitous Eduroam network, of which <a href="https://github.com/joostd/esp8266-eduroam">a github user joostd</a> provided the necessary interface.  I discovered later that the ESP8266 only functions for the WPA2 PSK version with MSCHAPv2 verification protocol, which my workplace's EDUROAM (and other locations) does not use. In any case, as a way of forcing myself to learn in depth about microcontrollers I chose to avoid the simplicity provided by Arduino.

An open-source framework built around the Espressif SDK was avaiable by <a href="https://github.com/pfalcon/esp-open-sdk">another GitHub user named pfalcon</a>.  This gave all the necessary components and the guide necessary to compile and flash to the ESP8266 microcontroller. The code is, like for most other microcontrollers, in C. My previous experience with C made the step to microcontrollers less abrupt. Additionally the compiler is gcc-like, with the flasing utility written in Python, both solidily in my comfort-zone. This functionality (luckily) was meant for use on linux machines, making it a proper step towards proper microcontroller development.

While the pin control is easily accessible in the SDK, physically the native SPI interface pins are not available on the ESP-01 (as described earlier). I had to write a <a href="https://en.wikipedia.org/wiki/Bit_banging">bit-banging</a> interface to the <a href="https://www.maximintegrated.com/en/products/power/display-power-control/MAX7221.html">MAX7221</a> 7-segment control chip. This code is stored separately from the other code for overall readability.  This was really key for debugging the later http requests, as simple response codes could tell me the degree of success.

The key to programming the ESP8266 with the open-SDK is that all work should be moved to the flash if entirely possible. Save for some special circumstances (which is excellently described in <a href="http://www.danielcasner.org/guidelines-for-writing-code-for-the-esp8266/">this blog post</a>), all functions should have "icache_flash_attr" in front to save RAM.  While I didn't explicitly need it, there are ways of also doing similar movements of variables as well.

That being said, some of the pre-compiled SDK libraries do not use follow this convention and therefore eat a lot of the available RAM. Even without much of my code, by just including the necessary libraries for the esphttpsclient (such as ssl), JSON and wifi libraries together was enough to exceed the RAM limit. As a solution I chose to rebuild the JSON package with the "icache_flash_attr" flag to get the RAM requirement under the limit. I was able to deduce that Espressif had utilized the <a href="https://github.com/contiki-os/contiki/tree/master/apps/json">Contiki-os</a> json parser from their header files, again making my job relatively easy. While my code is not complex, the RAM requirements needed for a larger project highlights the need for clever coding.

I must say that this project really does hinge on the work of <a href="https://github.com/Caerbannog/esphttpclient">GitHub user Caerbannog</a>, who did all of the legwork of writing an HTTP get and posts code for the Espressif SDK.  While initially I thought this portion of the code would take significant time to debug and validate, it took only a single example to get up to speed. Some modifications were needed for this project and it is given in the code section of the GitHub repository.

<h3> Putting it all together</h3>