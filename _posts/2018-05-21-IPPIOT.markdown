---
layout: post
title: "WiFi enabled 7-segment JSON display"
date: 2018-05-21
categories:
  - Side-Projects
description: 
image: https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/IPPIOT_title.png
image-sm: https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/IPPIOT_title.png
---
I wanted to build an Internet of Things (IoT) device while also improving my skills in microcontrollers and in design.  The main goal was to make a simple device while also being both a useful excercise and robust/usable product. With this in mind, I designed and built widget which connects to the internet, polls a website for a JSON, extracts a specific number (for example the experimental shot number or air quality index) and displays it via an SPI-connected 8-digit 7-segment display. The finished product feels like the 21st century equivalent of a bed-side clock, but with much more versatility. This project really highlights the revolution in design allowing for a hobbyist to make complicated products while maintaining both a low development cost and a fast design process.    

Doing this required three different segments, designing an integration between the two main electronic components, a housing to mate these components, and code to drive the whole device.  Each piece provided some unique difficulty,

This required solutions for the following challenges:

<ul>
  <li>Proper design tolerancing of parts for print variability and poor electronics workmanship</li>
  <li>PCB design which matches physical and electrical requirements at 3.3 and 5V</li>
  <li>Using the C-based workflow to properly utilize the ESP-01 </li>
</ul>

As it might seem that each problem is distinct and that these challenges are given cronologically, that was not the case. Each are significantly interrelated, where physical constraints impacted the electronic design which in turn changed the way in which the microcontroller would be programmed. The PCB design and case CAD design did progress before the actual coding, but after the general characteristics of the microcontroller control were defined. Overall, this project was enjoyable in the necessary problem solving, but also allowed me to take pride in the quality and finish of the end product. 

<h3> 3D printing of a compact housing</h3>

  <figure>
    <img src="https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/CAD_IPPIOT.jpg" alt="CAD of housing"/>
    <figcaption>The case was designed to be aestheically pleasing while also easy to be 3d printed. The two parts separate the 7 segment display from the control ESP8266 and interface board. Tolerancing was important for the screen, the micro USB interface, and mating surfaces between the 3d printed parts. </figcaption>
  </figure>


<h3> Designing and building an interfacing cicruit board</h3>


  <figure>
    <img src="https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/ESP8266_schematic.png" alt="Electronic schematic of mating board"/>
    <figcaption>The 7-segment display runs at 5V, with the ESP8266 at 3.3V. The interface board supplies the necessary voltages for these components (with a regulator), and the necessary level shifting for communcation (based off a similar Adafruit dev board). Micro USB was chosen due to the ubiquity of power sources (especially as things switch to USB-C).</figcaption>
  </figure>

  <figure>
    <img src="https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/g5517.png" alt="PCB CAD for mating board"/>
    <figcaption> Odd trace routing was necessary due to available IO pins on ESP-01. The 5 output pins are designed to match a specific 8 digit 7 segment display with a MAX7221. The hole beside the USB connector allows for a necessary M3 screw needed for mating the 3d printed case (showing how PCB and Case design occurred concurrently). Additional mounting screws and solder holes of Molex connector minimize strain on microUSB solder joint. </figcaption>
  </figure>

  <figure>
    <img src="https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/IMG_20180528_144417327.jpg" alt="PCB board progression"/>
    <figcaption>The design utilizes surface mount components to minimize the interface board size. Rather than using a reflow oven, components soldered by hand. This required a larger layout to reduce soldering difficulty.  The boards cheaply manufactured by Seeed Studio, by their printing standards..</figcaption>
  </figure>

<h3> Writing the microcontroller C code</h3>

When I first conceptualized the necessary components for this project, the implementation of arduino-based ESP8266 control was still in its infancy.  Initally, I wanted the wifi to connect to the rather ubiquitous Eduroam network, of which <a href="https://github.com/joostd/esp8266-eduroam">a github user joostd</a> provided the necessary interface.  However, the ESP8266 only functions for the WPA2 PSK version with MSCHAPv2 verification protocol, which my workplace's EDUROAM (and other locations) do not use. In any case, as a way of forcing myself to learn in depth about microcontrollers, I wanted to avoid the simplicity provide by arduino if entirely possible.

An open-source framework built around the Espressif SDK was avaiable by <a href="https://github.com/pfalcon/esp-open-sdk">another github user named pfalcon</a>.  This gave all the necessary components and the guide necessary to compile and flash to the ESP8266 microcontroller. The code is, like most other microcontrollers, in C. Additionally the compiler is gcc-like, with the flasing utility written in python. This functionality (luckily) was meant for use on linux machines, making it a proper step towards proper microcontroller development.

While the pin control is natively designed in the SDK, the native SPI interface pins are not available on the ESP-01 (as described earlier). I had to write a <a href="https://en.wikipedia.org/wiki/Bit_banging">bit-banging</a> interface to the <a href="https://www.maximintegrated.com/en/products/power/display-power-control/MAX7221.html">MAX7221</a> 7-segment control chip. This code is stored separately from the other code for overall readability.  This was really key for debugging the later http requests, as simple response codes could tell me degrees of success.

The key to programming the ESP8266 with the open-SDK is that all work should be moved from the flash if entirely possible. Save for some special circumstances (which is really well described in <a href="http://www.danielcasner.org/guidelines-for-writing-code-for-the-esp8266/">this blog post</a>), all functions should have "icache_flash_attr" in front to save RAM.  While I didn't explicitly need it, there are ways of also doing similar movements of variables as well.

That being said, some of the pre-compiled sdk libraries do not use this convention and therefore eat a lot of the RAM. Including the necessary libraries for https requests (such as ssl) as well as JSON parsing and wifi libraries exceeded the RAM. I had to compromise and chose to rebuild the JSON package with the "icache_flash_attr" flag to get the RAM necessary to the required limit.  Interestingly enough, I was able to deduce that Espressif had utilized the <a href="https://github.com/contiki-os/contiki/tree/master/apps/json">Contiki-os</a> json parser from the given header files, again making my job relatively easy. It could be that I didn't understand other tricks necessary for the ESP8266 RAM, but it seems to me that 

<h3> Putting it all together</h3>