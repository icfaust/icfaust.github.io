---
layout: post
title: "WiFi enabled 7-segment JSON display"
date: 2018-05-21
categories:
  - Side-Projects
description: 
image: https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/IPPIOT_title.png
image-sm: https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/IPPIOT_title.png
---
I wanted to build an Internet of Things (IoT) device while also improving my skills in microcontrollers and in design.  The main goal was to make a simple device while also being both a useful excercise and robust/usable product. With this in mind, I designed and built widget which connects to the internet, polls a website for a JSON, extracts a specific number (for example the experimental shot number or air quality index) and displays it via an SPI-connected 8-digit 7-segment display. The finished product feels like the 21st century equivalent of a bed-side clock, but with much more versatility. This project really highlights the revolution in design allowing for a hobbyist to make complicated products while maintaining both a low development cost and a fast design process.    

Doing this required three different segments, designing an integration between the two main electronic components, a housing to mate these components, and code to drive the whole device.  Each piece provided some unique difficulty,

This required solutions for the following challenges:

<ul>
  <li>Proper design tolerancing of parts for print variability and poor electronics workmanship</li>
  <li>PCB design which matches physical and electrical requirements at 3.3 and 5V</li>
  <li>Using the C-based workflow to properly utilize the ESP-01 </li>
</ul>

As it might seem that each problem is distinct and that these challenges are given cronologically, that was not the case. Each are significantly interrelated, where physical constraints impacted the electronic design which in turn changed the way in which the microcontroller would be programmed. The PCB design and case CAD design did progress before the actual coding, but after the general characteristics of the microcontroller control were defined. Overall, this project was enjoyable in the necessary problem solving, but also allowed me to take pride in the quality and finish of the end product. 

<h3> 3D printing of a compact housing</h3>

One of the great selling points of any 3D printer is the overall accuracy in creating extremely complex components.  However, as with all design and manufacturing, the devil is in the details.  The precision defines the overall ability of the printer to be tolerance, or manage errors in component or errors in how it relates to others. The case had to be taken care for the errors that were likely to exist, namely in mating the components and in integration the various printed circuit boards.  Finally, I also wanted the end result to be rigid, rugged, and to look nice.

  <figure>
    <img src="https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/CAD_IPPIOT.jpg" alt="CAD of housing"/>
    <figcaption>The case was designed to be aestheically pleasing while also easy to be 3D printed. The two parts separate the 7 segment display from the control ESP8266 and interface board. Tolerancing was important for the screen, the micro USB interface, and mating surfaces between the 3D printed parts. </figcaption>
  </figure>

The necessary PCBs to be housed within were a 7 segment display, an ESP8266 microcontroller and a board which contains power and communication between these two boards. The .56" 7-segment display and ESP8266 are both cheap and easy to acquire components, approximately $3 each on Amazon respectively. However, the cost and availability come at the cost in their tolerances. This shows readily in the exterior design, which had to take the tolerance issues into account while staying aesthetically pleasing. Fitting both of these requirements took significant time (hands off to product designers, that stuff is not easy).

The display PCB's 8 digits are separated into two 4 segment pieces. These pieces are roughly soldered in, and are often miss-aligned from one another by an angle or offset.  As seen in the CAD drawings 2 of the four screw holes of the display were used to screw the housing together.  The display is attached to the front panel by two screws. The threading holes are not centered within the housing due to the display PCB. The display is offset to one side. For the tolerance problems, the rectangular hole for the display has an additional millimeter gap to account for poor PCB construction.

The other two PCBs are screwed into back half and the two segments are electrically connected by 5 1" wires.  Two screws attach the interface board to the housing, and the interface board has a header to connect the ESP8266.  The surface of the interface board is set so that the Micro USB connector can sit nearly flush with the side of the housing. The two 3D printed pieces make the necessary hole for the USB connector. However, the dimensioning of this hole was made larger than necessary since I didn't trust my ability to surface mount solder accurately. The board screws reduce the strain in solder joint.

The ESP8266 board has a slightly smaller width than the interface board so that it can be recessed farther back in the housing. While this made sense from a mechanical design prospective, updating the flash on the microcontroller requires removing 4 of the 6 screws. This makes changing the WiFi network a pain and is definitely something I would do differently if I were to redesign it. The design also has a significantly large, useless void on the opposite side of the two boards which could be replaced by a battery in a future iteration.

The very thick nature of the device is really a product of the interfaces between the PCBs.  In one case, it needed to be wired, and the other with the use of a header.  Headers are inherently very large and contributed greatly to the overall size.  I now understand why there is such focus on single board phones and computers, and speciality connectors for components, as these greatly impact the thickness of the device. In this case, the overall size and weight make it much more of a small desk piece, rather than something for a pocket.

The housing pieces were first printed in sintered nylon and later versions in resin. I was used to PLA printers from other 3D printing projects, but I wanted to learn more about the accuracy, precision, and requirements of these other styles.  The nylon tends to accrue dirt easily due to the surface finish (as can be seen in some photos) and is a bit expensive. The resin is very high quality in precision, and while my printing service significantly scuffed the exterior, the surface is still very smooth (better than PLA and nylon). However, it is much more rigid and I think tapping the holes is necessary in resin rather than forcing in the M3 screws (which I do often in PLA and nylon). The error in these prints were less than .25mm, meaning that mating surfaces should be toleranced with .5mm so not too much play is allowed.  Both nylon and resin allow for very small features which is knowledge I will certainly use in the future.


<h3> Designing and building an interfacing cicruit board</h3>

The interfacing board was truly the hardest part of the entire process. It is what links the programming to the physical design, bring all of the various design pieces together.  It contains constraints from the mechanical design (such as the additional through hole), to the programming (3 IO outputs), to the electronic (the necessary 5V 3.3V level shifting). It was also my first personal attempt at ordering and negotiating the a PCB print house, which was previously done by my coworkers in the lab. I will admit, there were faults in the development process that I know now how not to repeat.

When developing the schematic, in the future I should do it concurrently with shopping for circuit elements.  For example, the micro USB connector was very expensive, as the available pad in EAGLE was meant only for Molex connectors.  Other, different layouts would have saved money and simplified ordering.  Also, unbeknownst to me at the time, but ordering speciality circuit components, especially surface mount components, are very difficult in Germany due to tax laws. Many of the typically large electronic sellers will simply not sell to individuals. This really drives up cost, and stifles hobby innovation.  To be frank, I was appalled. I think it is probably a signal that I need to be a part of a hackerspace or community lab.

  <figure>
    <img src="https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/ESP8266_schematic.png" alt="Electronic schematic of mating board"/>
    <figcaption>The 7-segment display runs at 5V, with the ESP8266 at 3.3V. The interface board supplies the necessary voltages for these components (with a regulator), and the necessary level shifting for communcation (based off a similar Adafruit dev board). Micro USB was chosen due to the ubiquity of power sources (especially as things switch to USB-C).</figcaption>
  </figure>

The greatest concern early on was figuring the power and voltage requirements of the circuit.  The ESP8266 uses 3.3V logic and will become damaged with 5V input. On the other hand, the display uses 5V.  I decided due to simplicity to base the whole device around micro USB due to the availability of chargers.  This also required the use of a regulator and three <a href="https://en.wikipedia.org/wiki/Level_shifter">level shifters</a>.  I simply relied on an <a href="https://www.adafruit.com/product/757">Adafruit breakout board</a> to design my own.

The 7 segment display utilizes an <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> interface, and does not have a MISO line.  This means 3 output pins talk from the ESP8266 to the MAX7221, and the remaining two providing power and ground.  The power can be directly linked from the USB to the display, and almost all other circuit components are used to isolate/translate the 3.3V functionality of the ESP8266.

  <figure>
    <img src="https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/g5517.png" alt="PCB CAD for mating board"/>
    <figcaption> Odd trace routing was necessary due to available IO pins on ESP-01. The 5 output pins are designed to match a specific 8 digit 7 segment display with a MAX7221. The hole beside the USB connector allows for a necessary M3 screw needed for mating the 3D printed case (showing how PCB and Case design occurred concurrently). Additional mounting screws and solder holes of Molex connector minimize strain on microUSB solder joint. </figcaption>
  </figure>

Soldering surface mount components with a typical soldering iron takes practice and dexterity. Assembling each board does take significant time, but there are great guides online to doing it this way.  The key is to only solder one pad, attach the surface component in the right position with that pad, and then solder the other pad to finish.  This makes it flat and in the right orientation with a strong connection.  I purposefully chose larger elements to simplify my soldering.  It was also likely a larger board than necessary to also simplify assembly.

Designing circuit boards cheaply require that they be 1) small 2) two layers and 3) of standard thickness.  It also helps that free PCB CAD softwares often have size limitations.  Due to the small nature of this project by size, this worked quite well to keep the price down. A lot of cheap houses are in China, and have month long turn around times, which was perfectly acceptable in this case.

  <figure>
    <img src="https://raw.githubusercontent.com/icfaust/icfaust.github.io/master/_screenshots/IMG_20180528_144417327.jpg" alt="PCB board progression"/>
    <figcaption>The design utilizes surface mount components to minimize the interface board size. Rather than using a reflow oven, components soldered by hand. This required a larger layout to reduce soldering difficulty.  The boards cheaply manufactured by Seeed Studio, by their printing standards.</figcaption>
  </figure>

Since I could only roughly estimate the necessary current needed to operate the device, and with an aversion to capactive coupling, I designed the traces to be wide and widely separated. The slow communication speed I utilizes (~1 kHz) was more than enough for this application.  The overall current draw was lower than I expected (nothing gets hot), so it is way overbuilt.  Future iterations would not need as powerful a regulator, and the board itself could probably be reduced in size.

<h3> Writing the microcontroller C code</h3>

When I first conceptualized the necessary components for this project, the implementation of Arduino-based ESP8266 control was still in its infancy.  Initally, I wanted the wifi to connect to the rather ubiquitous Eduroam network, of which <a href="https://github.com/joostd/esp8266-eduroam">a github user joostd</a> provided the necessary interface.  I discovered later that the ESP8266 only functions for the WPA2 PSK version with MSCHAPv2 verification protocol, which my workplace's EDUROAM (and other locations) does not use. In any case, as a way of forcing myself to learn in depth about microcontrollers I chose to avoid the simplicity provided by Arduino.

An open-source framework built around the Espressif SDK was available by <a href="https://github.com/pfalcon/esp-open-sdk">another GitHub user named pfalcon</a>.  This repository gives all the necessary components and the guide necessary to compile and flash to the ESP8266 microcontroller. The code is, like for most other microcontrollers, in C. My previous experience with C made the step to microcontrollers less abrupt. Additionally the compiler is gcc-like, with the flasing utility written in Python, both solidily in my comfort-zone. This functionality (luckily) was meant for use on linux machines, making it a useful step towards proper microcontroller development.

While the pin control is easily accessible in the SDK, physically the native SPI interface pins are not available on the ESP-01 (as described earlier). I had to write a <a href="https://en.wikipedia.org/wiki/Bit_banging">bit-banging</a> interface to the <a href="https://www.maximintegrated.com/en/products/power/display-power-control/MAX7221.html">MAX7221</a> 7-segment control chip. This code is stored separately from the other code for overall readability.  This was really key for debugging the later http requests, as simple response codes could tell me the degree of success.

The key to programming the ESP8266 with the open-SDK is that all work should be moved to the flash if entirely possible. Save for some special circumstances (which is excellently described in <a href="http://www.danielcasner.org/guidelines-for-writing-code-for-the-esp8266/">this blog post</a>), all functions should have "icache_flash_attr" in front to save RAM.  While I didn't explicitly need it, there are ways of also doing similar movements of variables as well.

That being said, some of the pre-compiled SDK libraries do not use follow this convention and therefore eat a lot of the available RAM. Even without much of my code, by just including the necessary libraries for the esphttpsclient (such as ssl), JSON and wifi libraries together was enough to exceed the RAM limit. As a solution I chose to rebuild the JSON package with the "icache_flash_attr" flag to get the RAM requirement under the limit. I was able to deduce that Espressif had utilized the <a href="https://github.com/contiki-os/contiki/tree/master/apps/json">Contiki-os</a> JSON parser from their header files, again making my job relatively easy. While my code is not complex, the RAM requirements needed for a larger project highlights the need for clever coding.

Finally, I must say that this project really does hinge on the work of <a href="https://github.com/Caerbannog/esphttpclient">GitHub user Caerbannog</a>, who did all of the legwork of writing an HTTP GET and HTTP POST code for the Espressif SDK.  While initially I thought this portion of the code would take significant time to debug and validate, it took only a single example to get up to speed. Some modifications were needed for this project and it is given in the code section of the GitHub repository.

<h3> Putting it all together</h3>